---
id: autowait
title: स्वतः-प्रतीक्षा
---

फलेकी टेस्ट के सबसे सामान्य कारणों में से एक उन तत्वों के साथ सहभागिता है जो उस समय आपके एप्लिकेशन में मौजूद नहीं हैं जब आप इसके साथ इंटरैक्ट करना चाहते हैं। आधुनिक वेब एप्लिकेशन बहुत गतिशील हैं, एलिमेंट दिखाई देते हैं और गायब हो जाते हैं। एक इंसान के रूप में हम अनजाने में एलिमेंट की प्रतीक्षा कर रहे हैं लेकिन एक स्वचालित स्क्रिप्ट में हम इसे एक क्रिया नहीं मानते हैं। किसी एलिमेंट को दिखाने के लिए प्रतीक्षा करने के दो तरीके हैं।

## अंतर्निहित बनाम स्पष्ट

वेबड्राइवर प्रोटोकॉल [अंतर्निहित टाइमआउट](https://w3c.github.io/webdriver/#timeouts) प्रदान करता है जो यह निर्दिष्ट करने की अनुमति देता है कि ड्राइवर को किसी एलिमेंट को दिखाने के लिए कितने समय तक प्रतीक्षा करनी चाहिए। डिफ़ॉल्ट रूप से यह टाइमआउट `0` पर सेट होता है और इसलिए यदि पृष्ठ पर कोई तत्व नहीं पाया जा सकता है तो ड्राइवर तुरंत `no such element` त्रुटि के साथ वापस आ जाता है। [`setTimeout`](/docs/api/browser/setTimeout) का उपयोग करके इस टाइमआउट को बढ़ाने से ड्राइवर प्रतीक्षा करेगा और इस बात की संभावना बढ़ जाएगी कि तत्व अंततः दिखाई देगा।

:::note

[टाइमआउट गाइड](/docs/timeouts)में वेबड्राइवर और फ्रेमवर्क संबंधित टाइमआउट के बारे में और पढ़ें

:::

स्पष्ट प्रतीक्षा का उपयोग करने के लिए एक अलग दृष्टिकोण है जो WebdriverIO फ्रेमवर्क में [`WaitForExist`](/docs/api/element/waitForExist)जैसे कमांड में बनाया गया है। इस तकनीक के साथ फ़्रेमवर्क कई [`FindElements`](/docs/api/webdriver#findelements) कमांड को कॉल करके एलिमेंट के लिए चुनाव करता है जब तक कि समय समाप्त नहीं हो जाता।

## बिल्ट-इन वेटिंग

दोनों प्रतीक्षा तंत्र एक दूसरे के साथ असंगत हैं और लंबे समय तक प्रतीक्षा कर सकते हैं। जैसा कि अंतर्निहित प्रतीक्षा एक वैश्विक सेटिंग है, यह उन सभी एलिमेंट पर लागू होती है जो कभी-कभी वांछित व्यवहार नहीं होते हैं। इसलिए WebdriverIO एक अंतर्निहित प्रतीक्षा तंत्र प्रदान करता है जो तत्व के साथ जुड़ने से पहले स्वचालित और स्पष्ट रूप से प्रतीक्षा करता है।

::: जानकारी की सिफारिश

हम निहित प्रतीक्षा का उपयोग __नहीं__ करने की अनुशंसा करते हैं और WebdriverIO को एलिमेंट प्रतीक्षा क्रियाओं को संभालने दें।

:::

अंतर्निहित प्रतीक्षा का उपयोग करना उन मामलों में भी समस्याग्रस्त है, जब आप किसी एलिमेंट के गायब होने तक प्रतीक्षा करने में रुचि रखते हैं। WebdriverIO एलिमेंट के लिए पोल का उपयोग तब तक करता है जब तक कि उसे कोई त्रुटि न मिल जाए। अंतर्निहित प्रतीक्षा विकल्प सेट होने से कमांड के निष्पादन में अनावश्यक रूप से विलंब होता है और लंबी परीक्षण अवधि हो सकती है।

आप अपने कॉन्फ़िगरेशन में [`वेट फॉर टाइम आउट`](/docs/configuration#waitfortimeout) विकल्प सेट करके WebdriverIOs स्वचालित स्पष्ट प्रतीक्षा के लिए एक डिफ़ॉल्ट मान सेट कर सकते हैं।

## सीमाएं

WebdriverIO केवल एलिमेंट की प्रतीक्षा कर सकता है जब वे निहित रूप से परिभाषित होते हैं। एलिमेंट फेच करने के लिए [`$`](/docs/api/browser/$) का उपयोग करते समय हमेशा ऐसा होता है। हालांकि इस तरह के एलिमेंट का एक सेट फेच करते समय यह समर्थित नहीं है

```js
const divs = await $$('div')
await divs[2].click() // can throw "Cannot read property 'click' of undefined"
```

एलिमेंट का एक सेट फेच करने और उस सेट के nवें एलिमेंट पर क्लिक करने के लिए यह एक पूर्ण वैध कार्रवाई है। हालाँकि WebdriverIO को यह नहीं पता है कि आप कितने एलिमेंट को दिखाने की उम्मीद कर रहे हैं। चूंकि [`$$`](/docs/api/browser/$$) WebdriverIO एलिमेंट की एक [सरणी](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) लौटाता है, इसलिए आपको मैन्युअल रूप से जांचना होगा कि वापसी मूल्य में पर्याप्त आइटम हैं या नहीं। हम इसके लिए [`WaitUntil`](/docs/api/browser/waitUntil) का उपयोग करने की अनुशंसा करते हैं, उदाहरण के लिए:

```js
const div = await browser.waitUntil(async () => {
    const elems = await $$('div')
    if (elems.length !== 2) {
        return false
    }

    return elems[2]
}, {
    timeoutMsg: 'Never found enough div elements'
})
await div.click()
```
