---
id: async-migration
title: सिंक से एसिंक तक
---

V8 में परिवर्तन के कारण WebdriverIO टीम [ने](https://webdriver.io/blog/2021/07/28/sync-api-deprecation) को अप्रैल 2023 तक सिंक्रोनस कमांड निष्पादन को रोकने की घोषणा की। टीम संक्रमण को यथासंभव आसान बनाने के लिए कड़ी मेहनत कर रही है। इस गाइड में हम समझाते हैं कि कैसे आप धीरे-धीरे अपने टेस्ट सूट को सिंक से एसिंक में माइग्रेट कर सकते हैं। एक उदाहरण परियोजना के रूप में हम [ककड़ी बॉयलरप्लेट](https://github.com/webdriverio/cucumber-boilerplate) का उपयोग करते हैं लेकिन अन्य सभी परियोजनाओं के साथ भी दृष्टिकोण समान है।

## जावास्क्रिप्ट में वादे

WebdriverIO में सिंक्रोनस निष्पादन लोकप्रिय होने का कारण यह है कि यह वादों से निपटने की जटिलता को दूर करता है। विशेष रूप से यदि आप अन्य भाषाओं से आते हैं जहाँ यह अवधारणा इस तरह मौजूद नहीं है, तो यह शुरुआत में भ्रमित करने वाली हो सकती है। हालाँकि एसिंक्रोनस कोड से निपटने के लिए वादे एक बहुत शक्तिशाली उपकरण हैं और आज का जावास्क्रिप्ट इससे निपटना वास्तव में आसान बनाता है। यदि आपने कभी प्रॉमिस के साथ काम नहीं किया है, तो हम अनुशंसा करते हैं कि आप इसके लिए [MDN संदर्भ गाइड](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) देखें क्योंकि इसे यहाँ समझाना संभव नहीं होगा।

## Async ट्रांजीशन

WebdriverIO टेस्टरनर एक ही टेस्ट सूट के भीतर async और सिंक निष्पादन को संभाल सकता है। इसका मतलब है कि आप धीरे-धीरे अपने परीक्षणों और पेजऑब्जेक्ट्स को अपनी गति से स्थानांतरित कर सकते हैं। उदाहरण के लिए, ककड़ी बॉयलरप्लेट ने आपके प्रोजेक्ट में कॉपी करने के लिए चरण परिभाषा</a> का एक बड़ा सेट

परिभाषित किया है। हम आगे बढ़ सकते हैं और एक बार में एक स्टेप डेफिनिशन या एक फाइल को माइग्रेट कर सकते हैं।</p> 

:::tip

WebdriverIO एक [कोडमोड](https://github.com/webdriverio/codemod) प्रदान करता है जो आपके सिंक कोड को async कोड में स्वचालित रूप से पूर्ण रूप से बदलने की अनुमति देता है। कोडमॉड को पहले डॉक्स में बताए अनुसार चलाएं और जरूरत पड़ने पर मैन्युअल माइग्रेशन के लिए इस गाइड का उपयोग करें।

:::  

कई मामलों में, जो कुछ करना आवश्यक है वह उस फ़ंक्शन को बनाना है जिसमें आप WebdriverIO कमांड को `async` कहते हैं और प्रत्येक कमांड के सामने `await` जोड़ते हैं। बॉयलरप्लेट प्रोजेक्ट में बदलने के लिए पहली फ़ाइल `clearInputField.ts` को देखते हुए, हम इससे ट्रांसफ़ॉर्म करते हैं:



```ts
export default (selector: Selector) => {
    $(selector).clearValue();
};
```


को:



```ts
export default async (selector: Selector) => {
    await $(selector).clearValue();
};
```


इतना ही! आप यहाँ सभी पुनर्लेखन उदाहरणों के साथ पूरी प्रतिबद्धता देख सकते हैं:



#### प्रतिबद्ध:

- _सभी चरण परिभाषाओं को रूपांतरित करें_ [[af6625f]](https://github.com/webdriverio/cucumber-boilerplate/pull/481/commits/af6625fcd01dc087479e84562f237ecf38b3537d)

:::जानकारी
यह संक्रमण इस बात से स्वतंत्र है कि आप टाइपस्क्रिप्ट का उपयोग करते हैं या नहीं। यदि आप टाइपस्क्रिप्ट का उपयोग करते हैं तो सुनिश्चित करें कि आप अंततः अपने `tsconfig.json` में `await` गुण को `webdriverio/sync` से `@wdio/globals/types`में बदल दें। यह भी सुनिश्चित करें कि आपका संकलन लक्ष्य कम से कम `ES2018`पर सेट है।
:::  



## विशेष स्थितियां

निश्चित रूप से हमेशा विशेष मामले होते हैं जहां आपको थोड़ा और ध्यान देने की आवश्यकता होती है।



### प्रत्येक लूप के लिए

यदि आपके पास प्रत्येक</code>forEach` है, उदाहरण के लिए तत्वों पर पुनरावृति करने के लिए, आपको यह सुनिश्चित करने की आवश्यकता है कि इटरेटर कॉलबैक को एसिंक तरीके से ठीक से संभाला जाता है, उदाहरण के लिए:</p>

<pre><code class="js">const elems = $$('div')
elems.forEach((elem) => {
    elem.click()
})
`</pre> 

प्रत्येक फ़ंक्शन को </code>forEach`में पास करते हैं, वह एक पुनरावर्तक फ़ंक्शन है। एक समकालिक दुनिया में यह आगे बढ़ने से पहले सभी तत्वों पर क्लिक करेगा। यदि हम इसे अतुल्यकालिक कोड में बदलते हैं, तो हमें यह सुनिश्चित करना होगा कि हम निष्पादन को पूरा करने के लिए प्रत्येक इटरेटर फ़ंक्शन की प्रतीक्षा करें। <code>async`await</code> जोड़कर ये पुनरावर्तक फ़ंक्शन एक वादा लौटाएंगे जिसे`हल करने की आवश्यकता है। अब, प्रत्येक`forEach`अब तत्वों पर पुनरावृति करने के लिए आदर्श नहीं है क्योंकि यह इटरेटर फ़ंक्शन के परिणाम को वापस नहीं करता है, जिस वादे के लिए हमें प्रतीक्षा करने की आवश्यकता है। इसलिए हमें <code>forEach` `map` से बदलने की आवश्यकता है जो उस वादे को वापस करता है। `map` के साथ-साथ Arrays के अन्य सभी पुनरावर्तक तरीके जैसे `find`, `every`, `reduce` और अधिक के माध्यम से कार्यान्वित किए जाते हैं। [p-पुनरावृति](https://www.npmjs.com/package/p-iteration) पैकेज और इसलिए async संदर्भ में उनका उपयोग करने के लिए सरलीकृत हैं। उपरोक्त उदाहरण इस तरह रूपांतरित दिखता है:



```js
const elems = await $$('div')
await elems.forEach((elem) => {
    return elem.click()
})
```


उदाहरण के लिए सभी `<h3 />` तत्वों को लाने और उनकी टेक्स्ट सामग्री प्राप्त करने के लिए, आप चला सकते हैं:



```js
await browser.url('https://webdriver.io')

const h3Texts = await browser.$$('h3').map((img) => img.getText())
console.log(h3Texts);
/**
 * returns:
 * [
 *   'Extendable',
 *   'Compatible',
 *   'Feature Rich',
 *   'Who is using WebdriverIO?',
 *   'Support for Modern Web and Mobile Frameworks',
 *   'Google Lighthouse Integration',
 *   'Watch Talks about WebdriverIO',
 *   'Get Started With WebdriverIO within Minutes'
 * ]
 */
```


यदि यह बहुत जटिल लगता है तो आप लूप के लिए सरल उपयोग करने पर विचार कर सकते हैं, उदाहरण के लिए:



```js
const elems = await $$('div')
for (const elem of elems) {
    await elem.click()
}
```




### WebdriverIO अभिकथन

यदि आप WebdriverIO अभिकथन हेल्पर [`expect-webdriverio`](https://webdriver.io/docs/api/expect-webdriverio) का उपयोग करते हैं, तो प्रत्येक `expect` कॉल के सामने `await` सेट करना सुनिश्चित करें, जैसे:



```ts
expect($('input')).toHaveAttributeContaining('class', 'form')
```


में बदलने की जरूरत है:



```ts
await expect($('input')).toHaveAttributeContaining('class', 'form')
```




### सिंक पेजऑब्जेक्ट मेथड्स और एसिंक्स टेस्ट

अगर आप अपने टेस्ट सूट में पेजऑब्जेक्ट्स को सिंक्रोनस तरीके से लिखते रहे हैं, तो अब आप एसिंक्रोनस टेस्ट में उनका इस्तेमाल नहीं कर पाएंगे। यदि आपको सिंक और एसिंक्स दोनों परीक्षणों में PageObject विधि का उपयोग करने की आवश्यकता है, तो हम विधि को डुप्लिकेट करने और उन्हें दोनों परिवेशों के लिए ऑफ़र करने की अनुशंसा करते हैं, उदा:



```js
class MyPageObject extends Page {
    /**
     * define elements
     */
    get btnStart () { return $('button=Start') }
    get loadedPage () { return $('#finish') }

    someMethod () {
        // sync code
    }

    someMethodAsync () {
        // async version of MyPageObject.someMethod()
    }
}
```


एक बार जब आप माइग्रेशन समाप्त कर लेते हैं तो आप सिंक्रोनस पेजऑब्जेक्ट विधियों को हटा सकते हैं और नामकरण को साफ कर सकते हैं।

यदि आप किसी PageObject विधि के दो अलग-अलग संस्करणों को बनाए रखना पसंद नहीं करते हैं, तो आप संपूर्ण PageObject को async में माइग्रेट कर सकते हैं और [`ब्राउज़र कॉल `](https://webdriver.io/docs/api/browser/call) का उपयोग कर सकते हैं। समकालिक वातावरण में विधि को निष्पादित करने के लिए करें, उदाहरण के लिए:



```js
// before:
// MyPageObject.someMethod()
// after:
browser.call(() => MyPageObject.someMethod())
```


`call` कमांड सुनिश्चित करेगा कि एसिंक्रोनस `someMethod` अगले कमांड पर जाने से पहले हल हो गया है।



## निष्कर्ष

जैसा कि आप [परिणामी पुनर्लेखन पीआर](https://github.com/webdriverio/cucumber-boilerplate/pull/481/files) में देख सकते हैं, इस पुनर्लेखन की जटिलता काफी आसान है। याद रखें कि आप उस समय एक चरण-परिभाषा को फिर से लिख सकते हैं। WebdriverIO एक ही ढांचे में सिंक और एसिंक निष्पादन को संभालने में पूरी तरह से सक्षम है।
