---
id: pageobjects
title: Page Object Pattern
---

5 версия WebdriverIO разработана с учетом поддержки Page Object. Внедрив принцип «объект первого класса», можно создавать большие наборы тестов, используя этот шаблон проектирования.

Для создания объектов страницы не требуются дополнительные пакеты. Оказывается, современные и чистые классы обеспечивают все функции, которые нам необходимы:

- наследование между объектами страницы
- отложенная загрузка элементов
- инкапсуляция для методов и действий

Цель использования Page Objects заключается в создании абстракции информации о странице, отделяя её от самих тестов. Идеально, при использовании Page Objects, все селекторы и методы, уникальные для страницы, должны храниться в объекте этой страницы, чтобы вы могли запустить тест после того, как полностью переделаете страницу.

## Создание Page Object

Для начало, нам нужен объект главной страницы, который мы называем `Page.js`. Он будет содержать общие селекторы или методы, от которых будут наследоваться все объекты страницы.

```js
// Page.js
export default class Page {
    constructor() {
        this.title = 'My Page'
    }

    async open (path) {
        await browser.url(path)
    }
}
```

Мы всегда будем экспортировать экземпляр объекта страницы и никогда не создавать этот экземпляр в тесте. При написании end-to-end тестов важно рассматривать веб-страницы как конструкции без состояния, аналогично тому, как каждый HTTP-запрос является конструкцией без сохранения состояния.

Конечно, браузер может хранить информацию о сеансе и отображать разные страницы в зависимости от различных сеансов пользователя. Однако это не должно отражаться в объекте страницы. Такие изменения состояния должны жить в ваших тестах.

Начнем тестирование первой страницы. В демонстрационных целях мы используем веб-сайт [The Internet](http://the-internet.herokuapp.com) website от [Elemental Selenium](http://elementalselenium.com) в качестве нашего подопытного. Давайте попробуем создать пример page object для страницы [login](http://the-internet.herokuapp.com/login).

## Получение селекторов

Первый шаг — написать все важные селекторы, которые требуются в нашем объекте `login.page`, как getter функции:

```js
// login.page.js
import Page from './page'

class LoginPage extends Page {

    get username () { return $('#username') }
    get password () { return $('#password') }
    get submitBtn () { return $('form button[type="submit"]') }
    get flash () { return $('#flash') }
    get headerLinks () { return $$('#header a') }

    async open () {
        await super.open('login')
    }

    async submit () {
        await this.submitBtn.click()
    }

}

export default new LoginPage()
```

Определение селекторов в геттер-функциях может показаться необычным, однако это действительно полезно. Эти функции вычисляются _при доступе к свойству_, а не при создании объекта. При этом вы всегда запрашиваете элемент, прежде чем выполнять над ним действие.

## Цепочка команд

WebdriverIO запоминает последний результат команды. Если вы соедините команду получения элемента с командой действия, она найдет элемент из предыдущей команды и использует результат для выполнения действия. При этом вы можете удалить селектор (первый параметр), и команда выглядит так же просто:

```js
await LoginPage.username.setValue('Max Mustermann')
```

Что, то же самое:

```js
let elem = await $('#username')
await elem.setValue('Max Mustermann')
```

или

```js
await $('#username').setValue('Max Mustermann')
```

## Использование Page Objects в тестах

После того как вы определили необходимые элементы и методы для страницы, можно приступать к написанию теста. Чтобы использовать page object в тестах, надо импортировать (`import` если вы используете модули ES6) или подключить с помощью `require` (если вы используете CommonJS). Вот и все!

Так как вы экспортировали экземпляр объекта страницы, импортируя его, вы сразу же сможете его использовать.

Если вы используете assert, ваши тесты могут быть еще более выразительными:

```js
// login.spec.js
import LoginPage from '../pageobjects/login.page'

describe('login form', () => {
    it('should deny access with wrong creds', async () => {
        await LoginPage.open()
        await LoginPage.username.setValue('foo')
        await LoginPage.password.setValue('bar')
        await LoginPage.submit()

        await expect(LoginPage.flash).toHaveText('Your username is invalid!')
    })

    it('should allow access with correct creds', async () => {
        await LoginPage.open()
        await LoginPage.username.setValue('tomsmith')
        await LoginPage.password.setValue('SuperSecretPassword!')
        await LoginPage.submit()

        await expect(LoginPage.flash).toHaveText('You logged into a secure area!')
    })
})
```

Со структурной стороны имеет смысл разделить файлы тестов и page object в разные каталоги. Кроме того, вы можете дать каждому объекту страницы окончание: `.page.js`. Это делает более понятным, что вы импортируете объект страницы.

## Дальше

Это основной принцип создания страниц с WebdriverIO. Но вы можете создавать гораздо более сложные структуры page object, чем эта! Например, у вас могут быть объекты страницы для модальных окон или вы можете разделить большой объект страницы на классы (представляющие отдельные части страницы), наследующиеся от основного объекта страницы. Использование этого подхода помогает отделить информацию о странице от самих тестов, что важно для поддержания структуры и набора тестов, особенно когда проект и количество тестов растут.

Этот пример (и даже больше примеров page object) в папке [`example`](https://github.com/webdriverio/webdriverio/tree/main/examples/pageobject) на GitHub.
